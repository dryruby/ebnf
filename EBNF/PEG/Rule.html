<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: EBNF::PEG::Rule
  
    &mdash; EBNF parser and parser generator
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "EBNF::PEG::Rule";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../_index.html">Index (R)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../EBNF.html" title="EBNF (module)">EBNF</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../PEG.html" title="EBNF::PEG (module)">PEG</a></span></span>
     &raquo; 
    <span class="title">Rule</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: EBNF::PEG::Rule
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  <dl>
      <dt>Includes:</dt>
      <dd><span class='object_link'><a href="../Unescape.html" title="EBNF::Unescape (module)">Unescape</a></span></dd>
  </dl>
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>lib/ebnf/peg/rule.rb</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    
<p>Behaviior for parsing a PEG rule</p>


  </div>
</div>
<div class="tags">
  

</div>


  <h2>Constant Summary</h2>
  
  <h3 class="inherited">Constants included
     from <span class='object_link'><a href="../Unescape.html" title="EBNF::Unescape (module)">Unescape</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="../Unescape.html#ECHAR-constant" title="EBNF::Unescape::ECHAR (constant)">Unescape::ECHAR</a></span>, <span class='object_link'><a href="../Unescape.html#ESCAPE_CHAR4-constant" title="EBNF::Unescape::ESCAPE_CHAR4 (constant)">Unescape::ESCAPE_CHAR4</a></span>, <span class='object_link'><a href="../Unescape.html#ESCAPE_CHAR8-constant" title="EBNF::Unescape::ESCAPE_CHAR8 (constant)">Unescape::ESCAPE_CHAR8</a></span>, <span class='object_link'><a href="../Unescape.html#ESCAPE_CHARS-constant" title="EBNF::Unescape::ESCAPE_CHARS (constant)">Unescape::ESCAPE_CHARS</a></span>, <span class='object_link'><a href="../Unescape.html#UCHAR-constant" title="EBNF::Unescape::UCHAR (constant)">Unescape::UCHAR</a></span></p>


  <h2>Instance Attribute Summary <small><a href="#" class="summary_toggle">collapse</a></small></h2>
  <ul class="summary">
    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#parser-instance_method" title="#parser (instance method)">#<strong>parser</strong>  &#x21d2; EBNF::PEG::Parser </a>
    

    
  </span>
  
  
  
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Initialized by parser when loading rules.</p>
</div></span>
  
</li>

    
  </ul>




  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eat_whitespace-instance_method" title="#eat_whitespace (instance method)">#<strong>eat_whitespace</strong>(input)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Eat whitespace between non-terminal rules.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#parse-instance_method" title="#parse (instance method)">#<strong>parse</strong>(input)  &#x21d2; Hash{Symbol =&gt; Object}, :unmatched </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>If there is are <code>start_production</code> and/or <code>production</code>, they are invoked with a <code>prod_data</code> stack, the input stream and offset.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rept-instance_method" title="#rept (instance method)">#<strong>rept</strong>(input, min, max, prod, string_regexp_opts, **options)  &#x21d2; :unmatched, Array </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Repitition, 0-1, 0-n, 1-n, â€¦</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  
  <h3 class="inherited">Methods included from <span class='object_link'><a href="../Unescape.html" title="EBNF::Unescape (module)">Unescape</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="../Unescape.html#unescape-class_method" title="EBNF::Unescape.unescape (method)">unescape</a></span>, <span class='object_link'><a href="../Unescape.html#unescape_codepoints-class_method" title="EBNF::Unescape.unescape_codepoints (method)">unescape_codepoints</a></span>, <span class='object_link'><a href="../Unescape.html#unescape_string-class_method" title="EBNF::Unescape.unescape_string (method)">unescape_string</a></span></p>

  <div id="instance_attr_details" class="attr_details">
    <h2>Instance Attribute Details</h2>
    
      
      <span id="parser=-instance_method"></span>
      <div class="method_details first">
  <h3 class="signature first" id="parser-instance_method">
  
    #<strong>parser</strong>  &#x21d2; <tt><span class='object_link'><a href="Parser.html" title="EBNF::PEG::Parser (module)">EBNF::PEG::Parser</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Initialized by parser when loading rules. Used for finding rules and invoking elements of the parse process.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Parser.html" title="EBNF::PEG::Parser (module)">EBNF::PEG::Parser</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>parser</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11
12
13</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ebnf/peg/rule.rb', line 11</span>

<span class='kw'>def</span> <span class='id identifier rubyid_parser'>parser</span>
  <span class='ivar'>@parser</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>


  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="eat_whitespace-instance_method">
  
    #<strong>eat_whitespace</strong>(input)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Eat whitespace between non-terminal rules</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


268
269
270
271
272
273
274
275</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ebnf/peg/rule.rb', line 268</span>

<span class='kw'>def</span> <span class='id identifier rubyid_eat_whitespace'>eat_whitespace</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_whitespace'>whitespace</span><span class='period'>.</span><span class='id identifier rubyid_is_a?'>is_a?</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='rparen'>)</span>
    <span class='comment'># Eat whitespace before a non-terminal
</span>    <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_skip'>skip</span><span class='lparen'>(</span><span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_whitespace'>whitespace</span><span class='rparen'>)</span>
  <span class='kw'>elsif</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_whitespace'>whitespace</span><span class='period'>.</span><span class='id identifier rubyid_is_a?'>is_a?</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="" title="EBNF::PEG::Rule (module)">Rule</a></span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_whitespace'>whitespace</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span> <span class='comment'># throw away result
</span>  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="parse-instance_method">
  
    #<strong>parse</strong>(input)  &#x21d2; <tt>Hash{Symbol =&gt; Object}</tt>, <tt>:unmatched</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>If there is are <code>start_production</code> and/or <code>production</code>, they are invoked with a <code>prod_data</code> stack, the input stream and offset. Otherwise, the results are added as an array value to a hash indexed by the rule name.</p>

<p>If matched, the input position is updated and the results returned in a Hash.</p>
<ul><li>
<p><code>alt</code>: returns the value of the matched production or <code>:unmatched</code>.</p>
</li><li>
<p><code>diff</code>: returns the value matched, or <code>:unmatched</code>.</p>
</li><li>
<p><code>hex</code>: returns a string composed of the matched hex character, or <code>:unmatched</code>.</p>
</li><li>
<p><code>opt</code>: returns the value matched, or <code>nil</code> if unmatched.</p>
</li><li>
<p><code>plus</code>: returns an array of the values matched for the specified production, or <code>:unmatched</code>, if none are matched. For Terminals, these are concatenated into a single string.</p>
</li><li>
<p><code>range</code>: returns a string composed of the values matched, or <code>:unmatched</code>, if less than <code>min</code> are matched.</p>
</li><li>
<p><code>rept</code>: returns an array of the values matched for the speficied production, or <code>:unmatched</code>, if none are matched. For Terminals, these are concatenated into a single string.</p>
</li><li>
<p><code>seq</code>: returns an array composed of single-entry hashes for each matched production indexed by the production name, or <code>:unmatched</code> if any production fails to match. For Terminals, returns a string created by concatenating these values. Via option in a <code>production</code> or definition, the result can be a single hash with values for each matched production; note that this is not always possible due to the possibility of repeated productions within the sequence.</p>
</li><li>
<p><code>star</code>: returns an array of the values matched for the specified production. For Terminals, these are concatenated into a single string.</p>
</li></ul>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>input</span>
      
      
        <span class='type'>(<tt>Scanner</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Hash{Symbol =&gt; Object}</tt>, <tt>:unmatched</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>A hash with keys for matched component of the expression. Returns :unmatched if the input does not match the production.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ebnf/peg/rule.rb', line 35</span>

<span class='kw'>def</span> <span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span>
  <span class='comment'># Save position and linenumber for backtracking
</span>  <span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_lineno'>lineno</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span>

  <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span> <span class='op'>||=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span>
    <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_debug'>debug</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_sym'>sym</span><span class='embexpr_end'>}</span><span class='tstring_content'>(:memo)</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>lineno:</span> <span class='id identifier rubyid_lineno'>lineno</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span><span class='embexpr_end'>}</span><span class='tstring_content'>(@</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_pos'>pos</span><span class='embexpr_end'>}</span><span class='tstring_content'>)</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span>
    <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:pos</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:lineno</span><span class='rbracket'>]</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:result</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>

  <span class='kw'>if</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
    <span class='comment'># If the terminal is defined with a regular expression,
</span>    <span class='comment'># use that to match the input,
</span>    <span class='comment'># otherwise,
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_regexp'>regexp</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_terminal_regexp'>terminal_regexp</span><span class='lparen'>(</span><span class='id identifier rubyid_sym'>sym</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_term_opts'>term_opts</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_terminal_options'>terminal_options</span><span class='lparen'>(</span><span class='id identifier rubyid_sym'>sym</span><span class='rparen'>)</span>
      <span class='kw'>if</span> <span class='id identifier rubyid_matched'>matched</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='id identifier rubyid_regexp'>regexp</span><span class='rparen'>)</span>
        <span class='comment'># Optionally map matched
</span>        <span class='id identifier rubyid_matched'>matched</span> <span class='op'>=</span> <span class='id identifier rubyid_term_opts'>term_opts</span><span class='period'>.</span><span class='id identifier rubyid_fetch'>fetch</span><span class='lparen'>(</span><span class='symbol'>:map</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_fetch'>fetch</span><span class='lparen'>(</span><span class='id identifier rubyid_matched'>matched</span><span class='period'>.</span><span class='id identifier rubyid_downcase'>downcase</span><span class='comma'>,</span> <span class='id identifier rubyid_matched'>matched</span><span class='rparen'>)</span>

        <span class='comment'># Optionally unescape matched
</span>        <span class='id identifier rubyid_matched'>matched</span> <span class='op'>=</span> <span class='id identifier rubyid_unescape'>unescape</span><span class='lparen'>(</span><span class='id identifier rubyid_matched'>matched</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_term_opts'>term_opts</span><span class='lbracket'>[</span><span class='symbol'>:unescape</span><span class='rbracket'>]</span>
      <span class='kw'>end</span>

      <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_onTerminal'>onTerminal</span><span class='lparen'>(</span><span class='id identifier rubyid_sym'>sym</span><span class='comma'>,</span> <span class='lparen'>(</span><span class='id identifier rubyid_matched'>matched</span> <span class='op'>?</span> <span class='id identifier rubyid_matched'>matched</span> <span class='op'>:</span> <span class='symbol'>:unmatched</span><span class='rparen'>)</span><span class='rparen'>)</span>

      <span class='comment'># Update furthest failure for strings and terminals
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_sym'>sym</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>==</span> <span class='symbol'>:unmatched</span>
      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span>
        <span class='label'>pos:</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span>
        <span class='label'>lineno:</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span>
        <span class='label'>result:</span> <span class='id identifier rubyid_result'>result</span>
      <span class='rbrace'>}</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:result</span><span class='rbracket'>]</span>
    <span class='kw'>end</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_eat_whitespace'>eat_whitespace</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_start_options'>start_options</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_onStart'>onStart</span><span class='lparen'>(</span><span class='id identifier rubyid_sym'>sym</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span> <span class='op'>=</span> <span class='id identifier rubyid_start_options'>start_options</span><span class='lbracket'>[</span><span class='symbol'>:insensitive_strings</span><span class='rbracket'>]</span> <span class='op'>?</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'>IGNORECASE</span> <span class='op'>:</span> <span class='int'>0</span>

  <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='kw'>case</span> <span class='id identifier rubyid_expr'>expr</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span>
  <span class='kw'>when</span> <span class='symbol'>:alt</span>
    <span class='comment'># Return the first expression to match.
</span>    <span class='comment'># Result is either :unmatched, or the value of the matching rule
</span>    <span class='id identifier rubyid_alt'>alt</span> <span class='op'>=</span> <span class='symbol'>:unmatched</span>
    <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_prod'>prod</span><span class='op'>|</span>
      <span class='id identifier rubyid_alt'>alt</span> <span class='op'>=</span> <span class='kw'>case</span> <span class='id identifier rubyid_prod'>prod</span>
      <span class='kw'>when</span> <span class='const'>Symbol</span>
        <span class='id identifier rubyid_rule'>rule</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_find_rule'>find_rule</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span>
        <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>No rule found for </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_prod'>prod</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_rule'>rule</span>
        <span class='id identifier rubyid_rule'>rule</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span>
      <span class='kw'>when</span> <span class='const'>String</span>
        <span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_quote'>quote</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='rparen'>)</span><span class='rparen'>)</span>
        <span class='kw'>case</span> <span class='id identifier rubyid_start_options'>start_options</span><span class='lbracket'>[</span><span class='symbol'>:insensitive_strings</span><span class='rbracket'>]</span>
        <span class='kw'>when</span> <span class='symbol'>:lower</span> <span class='kw'>then</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_downcase'>downcase</span>
        <span class='kw'>when</span> <span class='symbol'>:upper</span> <span class='kw'>then</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_upcase'>upcase</span>
        <span class='kw'>else</span> <span class='id identifier rubyid_s'>s</span>
        <span class='kw'>end</span> <span class='op'>||</span> <span class='symbol'>:unmatched</span>
      <span class='kw'>end</span>
      <span class='kw'>if</span> <span class='id identifier rubyid_alt'>alt</span> <span class='op'>==</span> <span class='symbol'>:unmatched</span>
        <span class='comment'># Update furthest failure for strings and terminals
</span>        <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_prod'>prod</span><span class='period'>.</span><span class='id identifier rubyid_is_a?'>is_a?</span><span class='lparen'>(</span><span class='const'>String</span><span class='rparen'>)</span> <span class='op'>||</span> <span class='id identifier rubyid_rule'>rule</span><span class='period'>.</span><span class='id identifier rubyid_terminal?'>terminal?</span>
      <span class='kw'>else</span>
        <span class='kw'>break</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_alt'>alt</span>
  <span class='kw'>when</span> <span class='symbol'>:diff</span>
    <span class='comment'># matches any string that matches A but does not match B.
</span>    <span class='comment'># (Note, this is only used for Terminal rules, non-terminals will use :not)
</span>    <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Diff used on non-terminal </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_prod'>prod</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
    <span class='id identifier rubyid_re1'>re1</span><span class='comma'>,</span> <span class='id identifier rubyid_re2'>re2</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_translate_codepoints'>translate_codepoints</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_translate_codepoints'>translate_codepoints</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>2</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_matched'>matched</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='id identifier rubyid_re1'>re1</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_matched'>matched</span> <span class='op'>||</span> <span class='id identifier rubyid_re2'>re2</span><span class='period'>.</span><span class='id identifier rubyid_match?'>match?</span><span class='lparen'>(</span><span class='id identifier rubyid_matched'>matched</span><span class='rparen'>)</span>
      <span class='comment'># Update furthest failure for terminals
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_sym'>sym</span><span class='rparen'>)</span>
      <span class='symbol'>:unmatched</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_matched'>matched</span>
    <span class='kw'>end</span>
  <span class='kw'>when</span> <span class='symbol'>:hex</span>
    <span class='comment'># Matches the given hex character if expression matches the character whose number (code point) in ISO/IEC 10646 is N. The number of leading zeros in the #xN form is insignificant.
</span>    <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='id identifier rubyid_to_regexp'>to_regexp</span><span class='rparen'>)</span> <span class='op'>||</span> <span class='kw'>begin</span>
      <span class='comment'># Update furthest failure for terminals
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='period'>.</span><span class='id identifier rubyid_last'>last</span><span class='rparen'>)</span>
      <span class='symbol'>:unmatched</span>
    <span class='kw'>end</span>
  <span class='kw'>when</span> <span class='symbol'>:not</span>
    <span class='comment'># matches any string that does not match B.
</span>    <span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='kw'>case</span> <span class='id identifier rubyid_prod'>prod</span> <span class='op'>=</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span>
    <span class='kw'>when</span> <span class='const'>Symbol</span>
      <span class='id identifier rubyid_rule'>rule</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_find_rule'>find_rule</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>No rule found for </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_prod'>prod</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_rule'>rule</span>
      <span class='id identifier rubyid_rule'>rule</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span>
    <span class='kw'>when</span> <span class='const'>String</span>
      <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_quote'>quote</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='op'>||</span> <span class='symbol'>:unmatched</span>
    <span class='kw'>end</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_res'>res</span> <span class='op'>!=</span> <span class='symbol'>:unmatched</span>
      <span class='comment'># Update furthest failure for terminals
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_sym'>sym</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
      <span class='symbol'>:unmatched</span>
    <span class='kw'>else</span>
      <span class='kw'>nil</span>
    <span class='kw'>end</span>
  <span class='kw'>when</span> <span class='symbol'>:opt</span>
    <span class='comment'># Result is the matched value or nil
</span>    <span class='id identifier rubyid_opt'>opt</span> <span class='op'>=</span> <span class='id identifier rubyid_rept'>rept</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='int'>1</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_start_options'>start_options</span><span class='rparen'>)</span>

    <span class='comment'># Update furthest failure for strings and terminals
</span>    <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
    <span class='id identifier rubyid_opt'>opt</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span>
  <span class='kw'>when</span> <span class='symbol'>:plus</span>
    <span class='comment'># Result is an array of all expressions while they match,
</span>    <span class='comment'># at least one must match
</span>    <span class='id identifier rubyid_plus'>plus</span> <span class='op'>=</span> <span class='id identifier rubyid_rept'>rept</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='comma'>,</span> <span class='int'>1</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='rparen'>)</span>

    <span class='comment'># Update furthest failure for strings and terminals
</span>    <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
    <span class='id identifier rubyid_plus'>plus</span><span class='period'>.</span><span class='id identifier rubyid_is_a?'>is_a?</span><span class='lparen'>(</span><span class='const'>Array</span><span class='rparen'>)</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_terminal?'>terminal?</span> <span class='op'>?</span> <span class='id identifier rubyid_plus'>plus</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='op'>:</span> <span class='id identifier rubyid_plus'>plus</span>
  <span class='kw'>when</span> <span class='symbol'>:range</span><span class='comma'>,</span> <span class='symbol'>:istr</span>
    <span class='comment'># Matches the specified character range
</span>    <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='id identifier rubyid_to_regexp'>to_regexp</span><span class='rparen'>)</span> <span class='op'>||</span> <span class='kw'>begin</span>
      <span class='comment'># Update furthest failure for strings and terminals
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span>
      <span class='symbol'>:unmatched</span>
    <span class='kw'>end</span>
  <span class='kw'>when</span> <span class='symbol'>:rept</span>
    <span class='comment'># Result is an array of all expressions while they match,
</span>    <span class='comment'># an empty array of none match
</span>    <span class='id identifier rubyid_rept'>rept</span> <span class='op'>=</span> <span class='id identifier rubyid_rept'>rept</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>2</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>3</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='rparen'>)</span>

    <span class='comment'># # Update furthest failure for strings and terminals
</span>    <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>3</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
    <span class='id identifier rubyid_rept'>rept</span><span class='period'>.</span><span class='id identifier rubyid_is_a?'>is_a?</span><span class='lparen'>(</span><span class='const'>Array</span><span class='rparen'>)</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_terminal?'>terminal?</span> <span class='op'>?</span> <span class='id identifier rubyid_rept'>rept</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='op'>:</span> <span class='id identifier rubyid_rept'>rept</span>
  <span class='kw'>when</span> <span class='symbol'>:seq</span>
    <span class='comment'># Evaluate each expression into an array of hashes where each hash contains a key from the associated production and the value is the parsed value of that production. Returns :unmatched if the input does not match the production. Value ordering is ensured by native Hash ordering.
</span>    <span class='id identifier rubyid_seq'>seq</span> <span class='op'>=</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each_with_object'>each_with_object</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_prod'>prod</span><span class='comma'>,</span> <span class='id identifier rubyid_accumulator'>accumulator</span><span class='op'>|</span>
      <span class='id identifier rubyid_eat_whitespace'>eat_whitespace</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='id identifier rubyid_accumulator'>accumulator</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span> <span class='op'>||</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
      <span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='kw'>case</span> <span class='id identifier rubyid_prod'>prod</span>
      <span class='kw'>when</span> <span class='const'>Symbol</span>
        <span class='id identifier rubyid_rule'>rule</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_find_rule'>find_rule</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span>
        <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>No rule found for </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_prod'>prod</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_rule'>rule</span>
        <span class='id identifier rubyid_rule'>rule</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span>
      <span class='kw'>when</span> <span class='const'>String</span>
        <span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_quote'>quote</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='rparen'>)</span><span class='rparen'>)</span>
        <span class='kw'>case</span> <span class='id identifier rubyid_start_options'>start_options</span><span class='lbracket'>[</span><span class='symbol'>:insensitive_strings</span><span class='rbracket'>]</span>
        <span class='kw'>when</span> <span class='symbol'>:lower</span> <span class='kw'>then</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_downcase'>downcase</span>
        <span class='kw'>when</span> <span class='symbol'>:upper</span> <span class='kw'>then</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_upcase'>upcase</span>
        <span class='kw'>else</span> <span class='id identifier rubyid_s'>s</span>
        <span class='kw'>end</span> <span class='op'>||</span> <span class='symbol'>:unmatched</span>
      <span class='kw'>end</span>
      <span class='kw'>if</span> <span class='id identifier rubyid_res'>res</span> <span class='op'>==</span> <span class='symbol'>:unmatched</span>
        <span class='comment'># Update furthest failure for strings and terminals
</span>        <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span>
        <span class='kw'>break</span> <span class='symbol'>:unmatched</span> 
      <span class='kw'>end</span>
      <span class='id identifier rubyid_accumulator'>accumulator</span> <span class='op'>&lt;&lt;</span> <span class='lbrace'>{</span><span class='id identifier rubyid_prod'>prod</span><span class='period'>.</span><span class='id identifier rubyid_to_sym'>to_sym</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_res'>res</span><span class='rbrace'>}</span>
    <span class='kw'>end</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_seq'>seq</span> <span class='op'>==</span> <span class='symbol'>:unmatched</span>
      <span class='symbol'>:unmatched</span>
    <span class='kw'>elsif</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
      <span class='id identifier rubyid_seq'>seq</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:values</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># Concat values for terminal production
</span>    <span class='kw'>elsif</span> <span class='id identifier rubyid_start_options'>start_options</span><span class='lbracket'>[</span><span class='symbol'>:as_hash</span><span class='rbracket'>]</span>
      <span class='id identifier rubyid_seq'>seq</span><span class='period'>.</span><span class='id identifier rubyid_inject'>inject</span> <span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_memo'>memo</span><span class='comma'>,</span> <span class='id identifier rubyid_h'>h</span><span class='op'>|</span> <span class='id identifier rubyid_memo'>memo</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_h'>h</span><span class='rparen'>)</span><span class='rbrace'>}</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_seq'>seq</span>
    <span class='kw'>end</span>
  <span class='kw'>when</span> <span class='symbol'>:star</span>
    <span class='comment'># Result is an array of all expressions while they match,
</span>    <span class='comment'># an empty array of none match
</span>    <span class='id identifier rubyid_star'>star</span> <span class='op'>=</span> <span class='id identifier rubyid_rept'>rept</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='rparen'>)</span>

    <span class='comment'># Update furthest failure for strings and terminals
</span>    <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_update_furthest_failure'>update_furthest_failure</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_expr'>expr</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
    <span class='id identifier rubyid_star'>star</span><span class='period'>.</span><span class='id identifier rubyid_is_a?'>is_a?</span><span class='lparen'>(</span><span class='const'>Array</span><span class='rparen'>)</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_terminal?'>terminal?</span> <span class='op'>?</span> <span class='id identifier rubyid_star'>star</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='op'>:</span> <span class='id identifier rubyid_star'>star</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>attempt to parse unknown rule type: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_expr'>expr</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>if</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>==</span> <span class='symbol'>:unmatched</span>
    <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span> <span class='op'>=</span> <span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='id identifier rubyid_lineno'>lineno</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_onFinish'>onFinish</span><span class='lparen'>(</span><span class='id identifier rubyid_result'>result</span><span class='rparen'>)</span>
  <span class='lparen'>(</span><span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span> <span class='op'>||=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='label'>pos:</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span>
    <span class='label'>lineno:</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span>
    <span class='label'>result:</span> <span class='id identifier rubyid_result'>result</span>
  <span class='rbrace'>}</span>
  <span class='kw'>return</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_packrat'>packrat</span><span class='lbracket'>[</span><span class='id identifier rubyid_sym'>sym</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='id identifier rubyid_pos'>pos</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:result</span><span class='rbracket'>]</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="rept-instance_method">
  
    #<strong>rept</strong>(input, min, max, prod, string_regexp_opts, **options)  &#x21d2; <tt>:unmatched</tt>, <tt>Array</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Repitition, 0-1, 0-n, 1-n, â€¦</p>

<p>Note, nil results are removed from the result, but count towards min/max calculations</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>input</span>
      
      
        <span class='type'>(<tt>Scanner</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>min</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>max</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>If it is an integer, it stops matching after max entries.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>prod</span>
      
      
        <span class='type'>(<tt>Symbol</tt>, <tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>string_regexp_opts</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>:unmatched</tt>, <tt>Array</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ebnf/peg/rule.rb', line 241</span>

<span class='kw'>def</span> <span class='id identifier rubyid_rept'>rept</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='comma'>,</span> <span class='id identifier rubyid_min'>min</span><span class='comma'>,</span> <span class='id identifier rubyid_max'>max</span><span class='comma'>,</span> <span class='id identifier rubyid_prod'>prod</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_options'>options</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>

  <span class='kw'>case</span> <span class='id identifier rubyid_prod'>prod</span>
  <span class='kw'>when</span> <span class='const'>Symbol</span>
    <span class='id identifier rubyid_rule'>rule</span> <span class='op'>=</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_find_rule'>find_rule</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>No rule found for </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_prod'>prod</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_rule'>rule</span>
    <span class='kw'>while</span> <span class='lparen'>(</span><span class='id identifier rubyid_max'>max</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span> <span class='op'>||</span> <span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_max'>max</span><span class='rparen'>)</span> <span class='op'>&amp;&amp;</span> <span class='lparen'>(</span><span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_rule'>rule</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='op'>!=</span> <span class='symbol'>:unmatched</span>
      <span class='id identifier rubyid_eat_whitespace'>eat_whitespace</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
      <span class='id identifier rubyid_result'>result</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_res'>res</span>
    <span class='kw'>end</span>
  <span class='kw'>when</span> <span class='const'>String</span>
    <span class='kw'>while</span> <span class='lparen'>(</span><span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span><span class='period'>.</span><span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_quote'>quote</span><span class='lparen'>(</span><span class='id identifier rubyid_prod'>prod</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_string_regexp_opts'>string_regexp_opts</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='op'>&amp;&amp;</span> <span class='lparen'>(</span><span class='id identifier rubyid_max'>max</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span> <span class='op'>||</span> <span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_max'>max</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_eat_whitespace'>eat_whitespace</span><span class='lparen'>(</span><span class='id identifier rubyid_input'>input</span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='id identifier rubyid_terminal?'>terminal?</span>
      <span class='id identifier rubyid_result'>result</span> <span class='op'>&lt;&lt;</span> <span class='kw'>case</span> <span class='id identifier rubyid_options'>options</span><span class='lbracket'>[</span><span class='symbol'>:insensitive_strings</span><span class='rbracket'>]</span>
      <span class='kw'>when</span> <span class='symbol'>:lower</span> <span class='kw'>then</span> <span class='id identifier rubyid_res'>res</span><span class='period'>.</span><span class='id identifier rubyid_downcase'>downcase</span>
      <span class='kw'>when</span> <span class='symbol'>:upper</span> <span class='kw'>then</span> <span class='id identifier rubyid_res'>res</span><span class='period'>.</span><span class='id identifier rubyid_upcase'>upcase</span>
      <span class='kw'>else</span> <span class='id identifier rubyid_res'>res</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_min'>min</span> <span class='op'>?</span> <span class='symbol'>:unmatched</span> <span class='op'>:</span> <span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Sat Jul 23 06:21:25 2022 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.28 (ruby-3.1.2).
</div>

    </div>
  </body>
</html>